Additive Function with Primes
=================================

#####Built on Ruby 2.1.1

Setup
=======

1. Clone to desktop
2. `cd` into project directory
3. Run `ruby additive_prime.rb`
4. Follow instructions!

About
=========
Built for a job interview code test. 

> You are given a function 'secret()' that accepts a single integer parameter and returns an integer. In a language of your choice, write an application that determines if this function is an additive function [ secret(x+y) = secret(x) + secret(y) ] for all prime numbers under N where N is a given integer.

Implementation
==========
In my program the 'secret()' function is in a seperate file labeled `secret_function.rb`.  There are actually 2 functions in that file. One is a perfectly linear additive function and the other is not. Both are very simple `y = mx + b` slope-intercept algebra functions. To call either one you need to rewrite your copy of additive_prime.rb and where it says `secret()` change to `so_totally_not_secret()` in the `check_if_additive` method.

--------

For my part a lot of my work was cut out for me. Ruby comes with built-in support for prime number finding and factoring. That saved me a lot of time. Before I found the prime module I was looking up seives and sweating bullets. 

Early versions of the program had nested while statements building prime number combinations. Basic math says `1 + 2` is the same thing as `2 + 1`. So if I was to check if `f(x+y) == f(x) + f(y)`, it didnt matter which order the digits went in. I didn't want to waste memory brute-force checking each combination over and over. 

For example I didn't want
```ruby
array = [1,2,3,4]
combos = []
array.each do |a|
	array.each do |b|
		combos << [a, b]
	end
end
```
Which spits out
```ruby
[[1, 2], [1, 1], [1, 2], [1, 3], [1, 4], [2, 1], [2, 2], [2, 3], [2, 4], [3, 1], [3, 2], [3, 3], [3, 4], [4, 1], [4, 2], [4, 3], [4, 4]]
```
We see we get a lot of redundant combos.

The code I came up with was
```ruby
	a = 0
	combos = Array.new
	while a < array.length do
		b = a + 1
		until b == array.length do
			combos << [array[a], array[b]]
			b += 1
		end
		a += 1
	end
```

Which worked pretty well. Then I found the .combination() method. 
```ruby
combos = array.combination(2).to_a
```
Much better. 1 > 9 lines of code.

Documentation
-----------
####Generated by RDoc
Once repo is cloned to desktop- navigate to kevy_additive_function_with_primes/doc/FindsIfAdditive.html