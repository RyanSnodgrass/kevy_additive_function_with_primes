Additive Function with Primes
=================================

#####Built on Ruby 2.1.1

Setup
=======

1. Clone to desktop
2. `cd` into project directory
3. Run `ruby additive_prime.rb`
4. Follow instructions!

About
=========
Built for a job interview code test. 

> You are given a function 'secret()' that accepts a single integer parameter and returns an integer. In a language of your choice, write an application that determines if this function is an additive function [ secret(x+y) = secret(x) + secret(y) ] for all prime numbers under N where N is a given integer.

Implementation
==========
###Switch Between `secret()` Functions
In my program the `secret()` function is in a separate file appropriately labeled `secret_function.rb`.  There are actually 2 functions in that file. One is a perfectly linear additive function and the other is not. Both are very simple `y = mx + b` slope-intercept algebra functions. To call either one you need to rewrite your copy of `additive_prime.rb` and where it says `secret()` change to `so_totally_not_secret()` in the `check_if_additive` method.

####Development
For my part a lot of my work was cut out for me. Ruby comes with built-in support for prime number finding and factoring. That saved me a lot of time. 

Early versions of the program had nested while statements building prime number combinations. Basic math says `1 + 2` is the same thing as `2 + 1`. So if I were to check if `f(x+y) == f(x) + f(y)`, it didn't matter which order the digits went in. For that reason I didn't want to waste memory brute-force checking each combination over and over. 

For example I didn't want
```ruby
array = [1,2,3,4]
combos = []
array.each do |a|
	array.each do |b|
		combos << [a, b]
	end
end
```
Which spits out
```
[[1, 2], [1, 1], [1, 2], [1, 3], [1, 4], 
[2, 1], [2, 2], [2, 3], [2, 4], 
[3, 1], [3, 2], [3, 3], [3, 4], 
[4, 1], [4, 2], [4, 3], [4, 4]]
```
We see we get a lot of redundant combos.

The code I came up with was
```ruby
	a = 0
	combos = Array.new
	while a < array.length do
		b = a + 1
		until b == array.length do
			combos << [array[a], array[b]]
			b += 1
		end
		a += 1
	end
```

Which worked pretty well and gave
```
[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
```

Then I found the `.combination()` method. 

```ruby
combos = array.combination(2).to_a
```
And that method returns the same thing, but with only 1 line of code instead of 9. Love it.

-------

A little bit of extra I put in: upon `secret()` failing, the program will tell you which combo block broke it. For now, since both functions are so simple- it's always the first one. Feel free to try your own functions in the `secret()` method and let me know if they pass when they aren't simple `y = mx` functions. Supposedly there are mathematicians out there studying non linear additive functions.

Documentation
-----------
####Generated by RDoc
Once repo is cloned to desktop- navigate to kevy_additive_function_with_primes/doc/FindsIfAdditive.html