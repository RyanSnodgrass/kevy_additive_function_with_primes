Additive Function with Primes
=================================

#####Built on Ruby 2.1.1

Setup
=======

1. Clone to desktop
2. `cd` into project directory
3. Run `ruby additive_prime.rb`
4. Follow instructions!

About
=========
Built for a job interview code test. 

> You are given a function 'secret()' that accepts a single integer parameter and returns an integer. In a language of your choice, write an application that determines if this function is an additive function [ secret(x+y) = secret(x) + secret(y) ] for all prime numbers under N where N is a given integer.

Implementation
==========
###Switch Between `secret()` Functions
In my program the `secret()` function is in a separate file appropriately labeled `secret_function.rb`.  There are actually 2 functions in that file. One is a perfectly linear additive function and the other is not. Both are very simple `y = mx + b` slope-intercept algebra functions. To call either one you need to rewrite your copy of `additive_prime.rb` and where it says `secret()` change to `so_totally_not_secret()` in the `check_if_additive` method.

####Development
For my part a lot of my work was cut out for me. Ruby comes with built-in support for prime number finding and factoring. That saved me a lot of time. 

Early versions of the program had nested while statements building prime number combinations. Basic math says `1 + 2` is the same thing as `2 + 1`. So if I were to check if `f(x+y) == f(x) + f(y)`, it didn't matter which order the digits went in. For that reason I didn't want to waste memory brute-force checking each combination over and over. 

For example I didn't want
```ruby
array = [1,2,3,4]
combos = []
array.each do |a|
	array.each do |b|
		combos << [a, b]
	end
end
```
Which spits out
```
[[1, 2], [1, 1], [1, 2], [1, 3], [1, 4], 
[2, 1], [2, 2], [2, 3], [2, 4], 
[3, 1], [3, 2], [3, 3], [3, 4], 
[4, 1], [4, 2], [4, 3], [4, 4]]
```
We see we get a lot of redundant combos.

The code I came up with was
```ruby
	a = 0
	combos = Array.new
	while a < array.length do
		b = a + 1
		until b == array.length do
			combos << [array[a], array[b]]
			b += 1
		end
		a += 1
	end
```

Which worked pretty well and gave
```
[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
```

Then I found the `.combination()` method. 

```ruby
combos = array.combination(2).to_a
```
Which returns
```
[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
```
The same thing, but with only 1 line of code instead of 9. Love it.

------

With the early code manually checking for combos, I had the additive check put in the middle of the block as it finds those combos.
```ruby
	def find_if_additive(x, y)
		unless secret(x+y) == secret(x) + secret(y)
			abort("The secret method is NOT additive")
		end
	end

	def find_prime_combos
		a = 0
		while a < @list_of_primes.length do
			b = a + 1
			until b == @list_of_primes.length do
				find_if_additive(@list_of_primes[a], @list_of_primes[b])
				b += 1
			end
			a += 1
		end
	end
```
Which is nice and it works, but the `.combination` method reduces a lot of that. After a bit of refactoring I had to break the combo finder into its own method.
```ruby
	def find_prime_combos
		@prime_combos = @list_of_primes.combination(2).to_a
	end
```
And then iterate over the `@prime_combos` array to `check_if_additive`. The result is much cleaner and I think even a little faster because of the built in methods.
```ruby
	def test_prime_combos_for_additive
		@prime_combos.each do |a|
			@iteration = a
			check_if_additive(a[0], a[1])
		end
	end
```

I put in a little bit of extra in the above. During each check, the current combo block is saved to the `@iteration` variable. If the check fails:
```ruby
	def check_if_additive(x, y)
		unless secret(x+y) == secret(x) + secret(y)
			puts "For prime combo #{@iteration.join(" and ")}"
			abort("The secret method has been proven NOT additive.")
		end
	end
```
The output string displays which combo block broke it. For now, since both functions are so simple- it's always the first one. Feel free to try your own functions in the `secret()` method and let me know if they pass when they aren't simple `y = mx` functions. 

Documentation
-----------
####Generated by RDoc
- Once repo is cloned to desktop- navigate to `kevy_additive_function_with_primes/doc/FindsIfAdditive.html`
- Open in your favorite browser!